# Команды с пользовательским вводом (также известные как «аргументы»)

Иногда вам нужно определить результат выполнения команды в зависимости от ввода пользователя. Это очень распространенный случай с очень простым решением. В этом разделе вы узнаете, как извлекать вводимые пользователем данные из сообщения и использовать их в своем коде. Обычно вы слышите, как другие люди называют это «аргументами», и вы должны относиться к ним именно так.

## Основные аргументы

На самом деле здесь мы будем заниматься сразу двумя вещами. Все будет объяснено по ходу дела, поэтому не волнуйтесь, если вы сразу не поймете.

Перейдите в основной файл бота и найдите `client.on('message', ...)` бит. Добавьте следующий блок кода в верхнюю часть функции обратного вызова этого прослушивателя событий (часть, которую мы заменили `...` здесь).

```js
if (!message.content.startsWith(prefix) || message.author.bot) return;

const args = message.content.slice(prefix.length).trim().split(' ');
const command = args.shift().toLowerCase();
```

1. Если сообщение не начинается с префикса или было отправлено ботом, выйдите раньше.
2. Создайте `args` переменную, которая полностью отсекает префикс, удаляет оставшиеся пробелы, а затем разбивает ее на массив по пробелам.
3. Создайте `command` переменную путем вызова `args.shift()`, который возьмет первый элемент в массиве и вернет его, а также удалит его из исходного массива (чтобы у вас не было строки имени команды внутри `args` массива).

Надеюсь, это немного яснее, если возникла какая-то путаница. Давайте создадим быструю команду, чтобы проверить результат нашего нового добавления:

```js
else if (command === 'args-info') {
	if (!args.length) {
		return message.channel.send(`You didn't provide any arguments, ${message.author}!`);
	}

	message.channel.send(`Command name: ${command}\nArguments: ${args}`);
}
```

Выглядит хорошо! Не беспокойтесь о разделении запятой; это ожидаемый результат при попытке отправить массив в виде строки.

Теперь, когда у вас есть массив аргументов, вы можете соответствующим образом взаимодействовать с ним! Попробуйте это небольшое дополнение к команде:

```js
else if (command === 'args-info') {
	if (!args.length) {
		return message.channel.send(`You didn't provide any arguments, ${message.author}!`);
	}
	else if (args[0] === 'foo') {
		return message.channel.send('bar');
	}

	message.channel.send(`First argument: ${args[0]}`);
}
```

Итак, если первый предоставленный аргумент равен «foo», то отправьте обратно «bar». В противном случае просто отправьте аргумент, предоставленный пользователем.

### Предостережения

В настоящее время вы используете `.split(' ')` для разделения аргументов команды. Однако на самом деле с этим есть небольшая проблема. Как есть, он разделит строку на каждый пробел.А что будет, если кто-то случайно (или даже намеренно) добавит дополнительные пробелы?

Если вы никогда раньше не делали что-то подобное, вероятно, вы этого не ожидали, верно? К счастью, для этой проблемы есть простое решение. Красная линия - это то, что нужно удалить, а зеленая линия - то, чем ее заменить.

```diff
- const args = message.content.slice(prefix.length).trim().split(' ');
+ const args = message.content.slice(prefix.length).trim().split(/ +/);
```

Потрясающие! Не о чем беспокоиться в этом отношении сейчас. Теперь вы используете нечто, называемое «регулярным выражением» (обычно называемое «регулярным выражением»), для обработки этой небольшой (но важной) ошибки.

## Общие ситуации с аргументами

Здесь мы рассмотрим несколько распространенных ситуаций, в которых вы захотите убедиться, что аргумент соответствует определенным критериям.

## Упоминания

Используя пример команды удара, вы, скорее всего, захотите, чтобы он позволял пользователю использовать команду и упоминать человека, которого нужно пнуть, верно? На самом деле мы не будем создавать полную команду удара в этом примере, но вот как вы можете это сделать:

```js
else if (command === 'kick') {
	// 1-го упомянутого пользователя
	// Возвращает объект пользователя
	const taggedUser = message.mentions.users.first();

	message.channel.send(`You wanted to kick: ${taggedUser.username}`);
}
```

Но что произойдет, если вы попытаетесь использовать команду, никого не упоминая? Если вы попробуете сами, вы заметите, что бот не отвечает (из-за сбоя), и вы должны увидеть что-то вроде этого в своей консоли:

```
message.channel.send(`You wanted to kick: ${taggedUser.username}`);
                                                      ^

TypeError: Cannot read property 'username' of undefined
```

Это потому, что вы пытаетесь получить доступ к `username` собственности пользователя, которого не упомянули! Поскольку `message.mentions.users` это коллекция, и вы пытаетесь вызвать `.first()` пустую коллекцию, она вернется `undefined`. Вы можете добавить быструю проверку согласованности над `const taggedUser = ...` линией, чтобы этого не произошло.

```js
if (!message.mentions.users.size) {
	return message.reply('you need to tag a user in order to kick them!');
}
```

> Если вам интересно, что `message.reply()` делает, это просто альтернатива, для `message.channel.send()` которой также добавляется упоминание человека, отправившего сообщение, если оно не используется в DM. Это может быть очень полезно для обратной связи!

Поскольку `message.mentions.users` это Коллекция, у нее есть `.size` свойство. Если пользователи не упомянуты, он вернет 0 (что является `falsy` значением), что означает, что вы можете `if (!value)` проверить, является ли это ложным.

### Работа с несколькими упоминаниями

Допустим, у вас есть какая-то `!avatar` команда, в которой будут отображаться аватары всех упомянутых пользователей или ваш собственный аватар, если пользователи не были упомянуты. Сосредоточьтесь на этой второй части - как бы вы сделали отображение своего аватара, если бы пользователи не были упомянуты? Взяв фрагмент кода, который вы только что использовали, вы можете сделать это так:

```js
else if (command === 'avatar') {
	if (!message.mentions.users.size) {
		return message.channel.send(`Your avatar: <${message.author.displayAvatarURL({ format: "png", dynamic: true })}>`);
	}

	// ...
}
```

Если эта `dynamic` опция предоставлена, вы получите `.gif` URL-адрес, если изображение анимировано, в противном случае оно вернется к указанному `format` или по умолчанию, `.webp` если ничего не указано.

Эта часть проста; просто переработайте оператор if, который вы использовали в разделе выше, и отобразите ссылку на ваш аватар.

Следующая часть - это то, что вам нужно - отображение аватарок всех упомянутых пользователей. Но это проще, чем вы думаете! `message.mentions.users` возвращает коллекцию (как упоминалось ранее), которую можно перебирать разными способами. Здесь вы будете использовать `.map()` цикл to, поскольку он позволяет легко собирать и хранить данные в переменной, чтобы в конце отправить одно последнее сообщение, а не несколько.

```js
else if (command === 'avatar') {
	if (!message.mentions.users.size) {
		return message.channel.send(`Your avatar: <${message.author.displayAvatarURL({ format: "png", dynamic: true })}>`);
	}

	const avatarList = message.mentions.users.map(user => {
		return `${user.username}'s avatar: <${user.displayAvatarURL({ format: "png", dynamic: true })}>`;
	});

	message.channel.send(avatarList);
}
```

Если эта `dynamic` опция предоставлена, вы получите `.gif` URL-адрес, если изображение анимировано, в противном случае оно вернется к указанному `format` или по умолчанию, `.webp` если ничего не указано.

И та-да! Теперь у вас есть список ссылок на аватары всех пользователей, которых вы отметили.

## Числовые диапазоны

Иногда вам нужно, чтобы пользователи вводили данные в диапазоне от X до Y, но ничего кроме этого. Кроме того, вы хотите убедиться, что они дают вам действительное число, а не случайные символы. Хорошим примером этого может быть `!prune` команда, которая удаляет X сообщений в канале, в зависимости от того, что вводит пользователь.

Первым шагом будет проверка, является ли введенный ими ввод действительным числом.

```js
else if (command === 'prune') {
	const amount = parseInt(args[0]);

	if (isNaN(amount)) {
		return message.reply('that doesn\'t seem to be a valid number.');
	}

	// ...
}
```

Итак, что вам нужно сделать дальше, это проверить, находится ли первый аргумент между X и Y. Следуя идее команды prune, вы, скорее всего, захотите использовать `.bulkDelete()` метод, который позволяет вам удалять несколько сообщений одним махом.

С учетом сказанного, этот метод имеет свои ограничения: вы можете удалить не менее 2 и не более 100 сообщений (за раз). К счастью, есть несколько способов справиться с этим. Один из таких способов - просто проверить значение `amount` переменной, например:

```js
if (isNaN(amount)) {
	return message.reply('that doesn\'t seem to be a valid number.');
} else if (amount < 2 || amount > 100) {
	return message.reply('you need to input a number between 2 and 100.');
}

// ...
```

Теперь осталось только удалить сообщения! Это простая одна строка кода:

```js
message.channel.bulkDelete(amount);
```

И у вас есть рабочая команда обрезки! Создайте тестовый канал, отправьте несколько случайных сообщений и проверьте его.

### Предостережения

Следует отметить, что в отношении этого .`bulkDelete()` метода есть несколько недостатков. Первый - это попытка удалить сообщения старше 2 недель, что обычно приводит к ошибке. Вот простое решение:

```js
message.channel.bulkDelete(amount, true);
```

Второй параметр в `.bulkDelete()` методе будет отфильтровывать сообщения старше 2 недель, если вы зададите ему истинное значение. Таким образом, если имеется 50 сообщений, и 25 из них старше 2 недель, он удалит только первые 25 без выдачи ошибки. Однако, если все сообщения, которые вы пытаетесь удалить, старше двух недель, это все равно будет выдавать ошибку. Зная это, вы должны отловить эту ошибку, связав файл `.catch()`.

```js
message.channel.bulkDelete(amount, true).catch(err => {
	console.error(err);
	message.channel.send('there was an error trying to prune messages in this channel!');
});
```

Другое предостережение заключается в том, !prune {number}что отправленное вами сообщение также будет учитываться в удалении. Это означает, что если вы отправите !prune 2, оно удалит это сообщение и только одно другое. Есть несколько способов обойти это, но для урока мы выберем самый простой путь. Вот изменения, которые нужно внести в текущий код:

```diff
- const amount = parseInt(args[0]);
+ const amount = parseInt(args[0]) + 1;
```

```diff
- else if (amount < 2 || amount > 100) {
-	return message.reply('you need to input a number between 2 and 100.');
- }
+ else if (amount <= 1 || amount > 100) {
+	return message.reply('you need to input a number between 1 and 99.');
+ }
```